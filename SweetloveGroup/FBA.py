#Function to convert any model with reversible reactions to a copy of the same m-
#-odel with only irreversible reactions. ID of reverse reactions are generated by 
#suffixing "_reverse" to the ID of the orignal reaction.
#args: 1) a cobra model
#output: a cobra model with only irreversible reactions
def rev2irrev(cobra_model):
  exp_model=cobra_model.copy()
  
  for RXN in cobra_model.reactions:
    rxn=exp_model.reactions.get_by_id(RXN.id)
    if (rxn.lower_bound < 0):
      rxn_reverse = rxn.copy()
      rxn_reverse.id = "%s_reverse" %(rxn.id)
      rxn.lower_bound = 0
      rxn_reverse.upper_bound = 0
      exp_model.add_reaction(rxn_reverse)
  
  return exp_model



#Function to constraint sum of fluxes when performing FBA
#args: 1) a cobra model, 2) a python list of reactions to leave out from constrai-
#-nt, 3) the float value that sum of fluxes must be constrained to & 4) value obj-
#-ective function needs to be constraint to (provide "" to avoid constraining obj-
#ective function)
#output: a cobra model with sum of fluxes constrained to 
def constrainSumOfFluxes(cobra_model, rxn2avoid,SFvalue,objvalue):
  temp=cobra_model.copy()
  SFMet = Metabolite("SFMet",name="Sum of fluxes pseudometabolite",compartment="c2")
  for rxn in cobra_model.reactions:
    if not rxn2avoid.__contains__(rxn.id):
      if rxn.id.__contains__("reverse"):
	temp.reactions.get_by_id(rxn.id).add_metabolites({SFMet:-1})
      else:
	temp.reactions.get_by_id(rxn.id).add_metabolites({SFMet:1})
  SFRxn = Reaction("SFRxn",name="Sum of fluxes pseudoreaction")
  SFRxn.add_metabolites({SFMet:-1})
  SFRxn.lower_bound=SFvalue
  SFRxn.upper_bound=SFvalue
  temp.add_reaction(SFRxn)
  if (not objvalue=="") and (len(temp.objective) == 1):
    for rxn in temp.objective.keys():
      rxn.lower_bound=objvalue
      rxn.upper_bound=objvalue
  return temp


#################################################################################
# This function is a modified version of cobrapy pfba function			#
#										#
#################################################################################

import logging
from warnings import warn
from itertools import chain

from optlang.symbolics import Zero

from cobra.util import solver as sutil
from cobra.core.solution import get_solution

def pfba_Weighted(model, weightings, fraction_of_optimum=1.0, objective=None, reactions=None):
    """Perform basic pFBA (parsimonious Enzyme Usage Flux Balance Analysis)
    to minimize total flux.
    pFBA [1] adds the minimization of all fluxes the the objective of the
    model. This approach is motivated by the idea that high fluxes have a
    higher enzyme turn-over and that since producing enzymes is costly,
    the cell will try to minimize overall flux while still maximizing the
    original objective function, e.g. the growth rate.
    Parameters
    ----------
    model : cobra.Model
        The model
    fraction_of_optimum : float, optional
        Fraction of optimum which must be maintained. The original objective
        reaction is constrained to be greater than maximal_value *
        fraction_of_optimum.
    objective : dict or model.problem.Objective
        A desired objective to use during optimization in addition to the
        pFBA objective. Dictionaries (reaction as key, coefficient as value)
        can be used for linear objectives.
    reactions : iterable
        List of reactions or reaction identifiers. Implies `return_frame` to
        be true. Only return fluxes for the given reactions. Faster than
        fetching all fluxes if only a few are needed.
    Returns
    -------
    cobra.Solution
        The solution object to the optimized model with pFBA constraints added.
    References
    ----------
    .. [1] Lewis, N. E., Hixson, K. K., Conrad, T. M., Lerman, J. A.,
       Charusanti, P., Polpitiya, A. D., Palsson, B. O. (2010). Omic data
       from evolved E. coli are consistent with computed optimal growth from
       genome-scale models. Molecular Systems Biology, 6,
       390. doi:10.1038/msb.2010.47
    """
    reactions = model.reactions if reactions is None \
        else model.reactions.get_by_any(reactions)
    with model as m:
        add_pfba_Weighted(m, weightings, objective=objective,
                 fraction_of_optimum=fraction_of_optimum)
        m.slim_optimize(error_value=None)
        solution = get_solution(m, reactions=reactions)
    return solution


#################################################################################
# This function is a modified version of cobrapy add_pfba function			#
#										#
#################################################################################

def add_pfba_Weighted(model, weightings, objective=None, fraction_of_optimum=1.0):
    """Add pFBA objective
    Add objective to minimize the summed flux of all reactions to the
    current objective.
    See Also
    -------
    pfba
    Parameters
    ----------
    model : cobra.Model
        The model to add the objective to
    objective :
        An objective to set in combination with the pFBA objective.
    fraction_of_optimum : float
        Fraction of optimum which must be maintained. The original objective
        reaction is constrained to be greater than maximal_value *
        fraction_of_optimum.
    """
    if objective is not None:
        model.objective = objective
    if model.solver.objective.name == '_pfba_objective':
        raise ValueError('The model already has a pFBA objective.')
    sutil.fix_objective_as_constraint(model, fraction=fraction_of_optimum)
    reaction_variables = ((rxn.forward_variable, rxn.reverse_variable)
                          for rxn in model.reactions)
    variables = chain(*reaction_variables)
    model.objective = model.problem.Objective(
        Zero, direction='min', sloppy=True, name="_pfba_objective")
    #print([v for v in variables])
    tempDict = dict()
    for v in variables:
        w = str(v).split("=")[1].replace(" ","").replace("<","")
        found=False
        for rxn in weightings.keys():
            if w.__contains__(rxn):
                #print(v)
                #print(rxn)
                tempDict[v]=weightings[rxn]
                found=True
                break
        if not found:
            print("Weightings for reaction "+rxn+" not found, so assuming weighting = 1")
            tempDict[v] = 1
    model.objective.set_linear_coefficients(tempDict)

